PeakML.DilutionTrendFilter <- function(filename,Rawpath=NULL,outputfile,ppm=0,rtwin=0, nSlaves=1, fillAll=FALSE, trendSets)
{
	st <- system.time (PeakMLdata <- PeakML.Read (filename,ionisation,Rawpath))

	ionisation <- PeakMLdata$massCorrection[[2]]
	massCorrection <- PeakMLdata$massCorrection[[1]]
	samplenames <- PeakMLdata$sampleNames
	rawdatafullpaths <- PeakMLdata$rawDataFullPaths
	
	if (is.null(rawdatafullpaths)){
		cat ("Some of the raw data files are not accessible, we will not be able to fill in missing peaks. Please set \"Rawpath\" argument with location where files can be located\n")
		stop ()
	}

	## Vector of all possible peaks for every sample in peakset
	numchromsexpected <- unlist(lapply(1:max(PeakMLdata$peakDataMtx[,10]),function (x) rep(x,length(samplenames))))

	## This table is used to generate information for chromatograms extraction/filling. 1st column - peakset number. 2nd-column presence/absence of the chromatogram in the peakml input file. 3rd column - data file number. 4th columns - index of chromatograms in PeakMLdata$chromDataList

	numchromsexpected <- cbind(numchromsexpected,NA,NA,NA)

	for (setnum in 1:max(PeakMLdata$peakDataMtx[,10])){
		inset <- c(1:length(samplenames))
		rownums <- which(PeakMLdata$peakDataMtx[,10]==setnum,9)
		hit <- PeakMLdata$peakDataMtx[PeakMLdata$peakDataMtx[,10]==setnum,9]
		numchromsexpected[which(numchromsexpected[,1]==setnum),2] <- as.numeric(inset%in%hit)
		missed <- which(inset%in%hit==FALSE)
		if (length(missed)>0)
		{
			detectedpeaks <- c(rep(1,length(hit)),rep(0,length(missed)))
			hit <- append(hit,missed)
			rownums <- append(rownums,rep(0,length(missed)))
		} else
			detectedpeaks <- rep(1,length(hit))
		{
		}
		numchromsexpected[which(numchromsexpected[,1]==setnum),3] <- hit
		numchromsexpected[which(numchromsexpected[,1]==setnum),2] <- detectedpeaks
		numchromsexpected[which(numchromsexpected[,1]==setnum),4] <- rownums
	}
	colnames(numchromsexpected) <- NULL

	## List object with mass chromatograms which are already in file
	chromslist <- vector("list",nrow(numchromsexpected))
	
	## Insert chromatograms from peakml file in the list
	#detected <- which(numchromsexpected[,2]==1)
	
	#system.time(
	#for (chrnum in 1:nrow(PeakMLdata$peakDataMtx)){
	#	chromslist[[detected[chrnum]]] <- rbind(masses,intensities,retentiontimes,scanids)
	#})


	#if fillAll is set to TRUE, all peaks will be reintegrated with given RT and mass window.
	if (fillAll==TRUE)
	{
		detectedchromatograms <- numchromsexpected[,2]
		numchromsexpected[,2] <- 0
	}

	## Now fill in missing peaks
	notdetected <- which(numchromsexpected[,2]==0)
	whichfiles <- numchromsexpected[notdetected,3]
	samplenums <- unique(whichfiles)
#	zerocount <- 0
#	nonzerocount <- 0
#	fillednums <- NULL

	if (length(samplenums!=0)){
		system.time(
		{
		for (filenum in 1:length(samplenums)){
			samplefile <- samplenums[filenum]

			# Retention times vector is used to detect scan numbers
			# rawfile <- xcmsRaw(rawdatafullpaths[samplefile])
			rawfile <- openMSfile (rawdatafullpaths[samplefile],verbose=FALSE)
			correctedRT <- as.numeric(PeakMLdata$correctedRTList[[samplefile]])
			uncorrectedRT <- header(rawfile)$retentionTime
			if (all(correctedRT==uncorrectedRT))
			{
				rtCorrection <- FALSE
			} else
			{
				rtCorrection <- TRUE
			}

			## detect which peaks to fill in for current data file
			fillinnums <- notdetected[whichfiles==samplefile]
			
			isSnow <- FALSE
			if (nSlaves>1){
				tryCatch(isSnow <- require(snow, quietly=TRUE), warning=function(e) 
				print ("Pleae install package snow to use multiple processors. \n We will continue with a single processor for the time being."))
			}
			if (isSnow==TRUE){
				library (snow)
				if (filenum==1)
				{
					cat("Package snow loaded.","\n")
				}
				cl <- makeCluster (nSlaves)
				assign ("rtwin",rtwin,envir=.GlobalEnv)
				assign ("rawfile",rawfile,envir=.GlobalEnv)
				assign ("numchromsexpected",numchromsexpected,envir=.GlobalEnv)
				assign ("fillinnums",fillinnums,envir=.GlobalEnv)
				assign ("PeakMLdata$peakDataMtx",PeakMLdata$peakDataMtx,envir=.GlobalEnv)
				assign ("ppm",ppm,envir=.GlobalEnv)
				assign ("FillinPeaks",FillinPeaks,ppm,envir=.GlobalEnv)
				assign ("rawMat",rawMat,envir=.GlobalEnv)
				clusterExport(cl, list=c("rtwin","rawfile", "numchromsexpected", "fillinnums", "PeakMLdata$peakDataMtx", "ppm","FillinPeaks","rawMat"))
				filledlist <- parLapply(cl, c(1:length(fillinnums)), FillinPeaks)
				stopCluster (cl)
			}else{
				filledlist <- lapply(1:length(fillinnums),FillinPeaks)
			}
			
			## For debug purpose only
			#for (bd in 1: length(fillinnums))
			#{
			#	cat (bd,"\n")
			#	FillinPeaks(bd)
			#}

#			assign ("zerocount",zerocount,envir=.GlobalEnv)
#			assign ("nonzerocount",nonzerocount,envir=.GlobalEnv)
#			assign ("fillednums",fillednums,envir=.GlobalEnv)
			
			for (i in 1:length(filledlist)){
				chromslist[[fillinnums[i]]] <- filledlist[[i]]
			}
			#close (rawfile)
			rm (rawfile,filledlist)
		}
		})
	}
	
	##SetNames, if peakml file has a several peaksets, they will be restored.
	#samplegroups=PeakMLdata$peakDataMtx[,11]
	#sampleclasses <- .jcall(project,returnSig="[S", method="getSetNames")

	#samplelookfunction <- function (x)	
	#{
	#	phenoData <- sampleclasses[samplegroups[PeakMLdata$peakDataMtx[,9]==x][1]]
	#	phenoData
	#}
	#phenoData <- PeakMLdata$phenoData

	## Wipe out some unused large objects before writing
	# rm (masschromatograms,project)
	# rm (PeakMLdata) # as masschromatograms is inside a function now
	## Write all of this out
	
	project <- .jnew("peakml/util/rjava/Project", samplenames, rawdatafullpaths, as.character(PeakMLdata$phenoData))
	# Insert peakpicker method name ir peakML file header.
	## public void addHeaderAnnotation(String label, String value)	
	.jcall(project, returnSig="V", method="addHeaderAnnotation",as.character("peakproc"),as.character("XCMS_Gapfilled"))
	
	# Inserting Scan numbers, RT corrected and RT raw for every sample
	for (measurementid in 1:length(samplenames)){
		for (scannum in 1:length(PeakMLdata$correctedRTList[[measurementid]])){
		.jcall(project, returnSig="V", method="addScanInfo", as.integer(measurementid-1),as.numeric(PeakMLdata$correctedRTList[[measurementid]][scannum]),as.character(ionisation))
		.jcall(project, returnSig="V", method="addScanAnnotation", as.integer(measurementid-1),as.integer(scannum-1),as.character("RT_raw"),as.character(PeakMLdata$rawRTList[[measurementid]][scannum]))
		}
	}
	

	# finally we can store the mass chromatogram in our project
	# subtract 1 from the measurementid to get in line with java
	# Filled chromatograms are taken from chromslist object, but existing ones from PeakMLdata$chromDataList

	for (i in 1:length(chromslist)){
		if (numchromsexpected[i,2]==0)
		{
			chrom <- chromslist[[i]]
		} else
		{
			ind <- numchromsexpected[i,4]
			chrom <- PeakMLdata$chromDataList[[ind]]
		}
		.jcall(project, returnSig="V", method="addMassChromatogram", as.integer(numchromsexpected[i,3]-1), as.integer(chrom[4,]), as.numeric(chrom[3,]),as.numeric(chrom[1,]), as.numeric(chrom[2,]), as.character(ionisation))
	}

	# now the mass chromatogram data has been collected the sets can be created - *sigh* memory consumption is such a bitch
	# -> this assumes that the sorting remains constant
	## Make a list with peak numbers which should be grouped together in sets
	setindexes <- vector("list",length(unique(numchromsexpected[,1])))
	
	for (indexnumber in 1:length(setindexes)){
		setindexes[[indexnumber]] <- which(numchromsexpected[,1]==indexnumber)
	}
	for (ind in 1:length(setindexes)){
		.jcall(project, returnSig="V", method="addPeakSet", as.integer(setindexes[[ind]]-1))
	}


	## Restore peak annotations data

	if (!is.null(PeakMLdata$GroupAnnotations))
	{
		PeakML.Methods.writeGroupAnnotations (project, PeakMLdata$GroupAnnotations)
	}

	## Add Annotations to the peaks which are filled in, and which not.
	
	
	## Now we can add extra atributes to masschromatogram sets (groups in XCMS)
	## public void addGroupAnnotation(int groupid, String label, String value)
#	fillindex <- rep (0,length(setindexes))
#	## Peak sets which were appended
#	fillindex[unique(numchromsexpected[fillednums,1])] <- 1
#	for (groupnumber in 1:length(setindexes)){
#		.jcall(project, returnSig="V",method="addGroupAnnotation",as.integer(groupnumber-1), as.character("gap.filled"),as.character(fillindex[groupnumber]))
#	}

	## Finally write file
	#cat(zerocount," of fillled in mass chromatograms are removed (length <3 scans)\n")
	#cat (nonzerocount,"mass chromatogramms filled in.\n")
	.jcall(project, returnSig="V", method="write", outputfile)
}
